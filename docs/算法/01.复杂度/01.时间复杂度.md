---
title: "时间复杂度"
date: "2019-11-29"
permalink: "2019-11-29-算法-时间复杂度"
---

## 前言

算法（Algorithm）是指用来操作数据、解决程序问题的一组方法。对于同一个问题，使用不同的算法，也许最终得到的结果是一样的，比如排序就有前面的十大经典排序和几种奇葩排序，虽然结果相同，但在过程中消耗的资源和时间却会有很大的区别，比如快速排序与猴子排序：）。

那么我们应该如何去衡量不同算法之间的优劣呢？

主要还是从算法所占用的「时间」和「空间」两个维度去考量。	<br/>
* 时间维度：是指执行当前算法所消耗的时间，我们通常用「时间复杂度」来描述。	<br/>
* 空间维度：是指执行当前算法需要占用多少内存空间，我们通常用「空间复杂度」来描述。	<br/>

本小节将从「时间」的维度进行分析。

## 什么是大O

当看「时间」二字，我们肯定可以想到将该算法程序运行一篇，通过运行的时间很容易就知道复杂度了。

这种方式可以吗？当然可以，不过它也有很多弊端。

比如程序员小吴的老式电脑处理10w数据使用冒泡排序要几秒，但读者的iMac Pro 可能只需要0.1s，这样的结果误差就很大了。更何况，有的算法运行时间要很久，根本没办法没时间去完整的运行，还是比如猴子排序：）。

那有什么方法可以严谨的进行算法的时间复杂度分析呢？

有的!

「 远古 」的程序员大佬们提出了通用的方法：「 大O符号表示法 」，即 `T(n) = O(f(n))`。

`其中 n 表示数据规模 ，O(f(n))表示运行算法所需要执行的指令数，和f(n)成正比。`

>上面公式中用到的 Landau符号是由德国数论学家保罗·巴赫曼（Paul Bachmann）在其1892年的著作《解析数论》首先引入，由另一位德国数论学家艾德蒙·朗道（Edmund Landau）推广。Landau符号的作用在于用简单的函数来描述复杂函数行为，给出一个上或下（确）界。在计算算法复杂度时一般只用到大O符号，Landau符号体系中的小o符号、Θ符号等等比较不常用。这里的O，最初是用大写希腊字母，但现在都用大写英语字母O；小o符号也是用小写英语字母o，Θ符号则维持大写希腊字母Θ。

## 常见的时间复杂度量级

我们先从常见的时间复杂度量级进行大O的理解：

* 常数阶O(1)

* 线性阶O(n)

* 平方阶O(n²)

* 对数阶O(logn)

* 线性对数阶O(nlogn)

<img src="https://user-gold-cdn.xitu.io/2018/12/13/167a509fc39ca44c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="GitHub" title="GitHub,Social Coding" width="652" height="462" />


### O(1):

<img src="https://mmbiz.qpic.cn/mmbiz_gif/D67peceibeISTRz5ibO62oFJIY3OQIc2nQuj6PnaS8BTJfAM6uhHCQdjibvWicNJbaWBia1To9WBwc43Crw64c5vPzw/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1" alt="GitHub" title="GitHub,Social Coding"/>

无论代码执行了多少行，其他区域不会影响到操作，这个代码的时间复杂度都是O(1)

```js
function testO1(a,b){
  const temp = a;
  a = b;
  b = temp;
}
```

